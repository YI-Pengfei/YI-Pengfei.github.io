<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://YI-Pengfei.github.io</id>
    <title>飞天小南鲸</title>
    <updated>2020-07-06T10:52:20.620Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://YI-Pengfei.github.io"/>
    <link rel="self" href="https://YI-Pengfei.github.io/atom.xml"/>
    <subtitle>记得戴口罩</subtitle>
    <logo>https://YI-Pengfei.github.io/images/avatar.png</logo>
    <icon>https://YI-Pengfei.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 飞天小南鲸</rights>
    <entry>
        <title type="html"><![CDATA[无人机通信阅读记录-综述]]></title>
        <id>https://YI-Pengfei.github.io/post/wu-ren-ji-tong-xin-yue-du-ji-lu-zong-shu/</id>
        <link href="https://YI-Pengfei.github.io/post/wu-ren-ji-tong-xin-yue-du-ji-lu-zong-shu/">
        </link>
        <updated>2020-05-10T08:54:39.000Z</updated>
        <content type="html"><![CDATA[<h3 id="survey-on-unmanned-aerial-vehicle-networks-a-cyber-physical-system-perspective">Survey on Unmanned Aerial Vehicle Networks: A Cyber Physical System Perspective</h3>
<ul>
<li>
<p>无人机信息物理系统CPS组件</p>
<ul>
<li>通信<br>
<img src="https://YI-Pengfei.github.io/post-images/1589100938739.png" alt="" loading="lazy"></li>
<li>计算</li>
<li>控制
<ul>
<li>UAV network of cell level (UCL)</li>
<li>UAV network of system level (USL)</li>
<li>UAV network of system of system level (USoS)</li>
</ul>
</li>
</ul>
</li>
<li>
<p>三个层级：<br>
<img src="https://YI-Pengfei.github.io/post-images/1589111556060.png" alt="" loading="lazy"></p>
<ul>
<li>细胞级<br>
<img src="https://YI-Pengfei.github.io/post-images/1589112938797.png" alt="" loading="lazy"><br>
<img src="https://YI-Pengfei.github.io/post-images/1589113749744.png" alt="" loading="lazy"></li>
<li>系统级<br>
<img src="https://YI-Pengfei.github.io/post-images/1589112912370.png" alt="" loading="lazy"><br>
<img src="https://YI-Pengfei.github.io/post-images/1589113901830.png" alt="" loading="lazy"></li>
<li>系统的系统级 system of system level</li>
</ul>
</li>
</ul>
<h3 id="accessing-from-the-sky-a-tutorial-on-uav-communications-for-5g-and-beyond">Accessing From the Sky: A Tutorial on UAV Communications for 5G and Beyond</h3>
<ul>
<li>信道<br>
<img src="https://YI-Pengfei.github.io/post-images/1589694183212.png" alt="" loading="lazy"></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[无人机通信阅读记录-IEEE Wireless Communications]]></title>
        <id>https://YI-Pengfei.github.io/post/wu-ren-ji-tong-xin-yue-du-ji-lu-ieee-wireless-communications/</id>
        <link href="https://YI-Pengfei.github.io/post/wu-ren-ji-tong-xin-yue-du-ji-lu-ieee-wireless-communications/">
        </link>
        <updated>2020-05-05T04:18:20.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li><strong>Research Challenges and Opportunities of UAV Millimeter-Wave Communications</strong></li>
</ol>
<ul>
<li><img src="https://YI-Pengfei.github.io/post-images/1588652394306.png" alt="" loading="lazy"></li>
<li>UAV Channel Acquisition and Precoder Design
<ul>
<li>UAV Channel Estimation
<ul>
<li>Channel variation effect is one of the most severe issues for UAV communication, and <em>fast channel estimation for a high-mobility UAV communication system</em> is required</li>
</ul>
</li>
<li>UAV Fast Beam Training and Tracking
<ul>
<li>毫米波系统中，信道通常由有限数量的多路分量，可表示为路径增益与导向矢量（或波束）的乘积</li>
<li>UAV的高动态导致路径增益和波束到达/发射角的快速变化</li>
<li>因此需要efficient beam training methods+beam tracking</li>
</ul>
</li>
<li>Intermittent Path Change 断断续续的路径变化
<ul>
<li>多路分量随着UAV的随机移动而改变，对设计预编码器和波束形成码书造成挑战</li>
</ul>
</li>
</ul>
</li>
<li>UAV MmWave For Cellular Network</li>
</ul>
<ol start="2">
<li><strong>Physical Layer Security in UAV Systems: Challenges and Opportunities</strong></li>
</ol>
<ul>
<li>被动窃听，主动干扰</li>
<li>反窃听技术 Anti-Eavesdropping Techniques：
<ul>
<li><strong>Joint Trajectory and Resource Allocation Design</strong></li>
<li>Robust Joint Design 当窃听位置部分已知或统计上的位置已知时</li>
<li>Artificial Noise</li>
</ul>
</li>
<li>先进技术：
<ul>
<li>NOMA</li>
<li>3D Beamforming</li>
<li>MmWave</li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>Fundamental Trade-offs in  Communication and Trajectory Design for UAV-Wireless Network</strong></li>
</ol>
<ul>
<li>UAV-ground通信的主要优势：
<ul>
<li>Line-of-sight (LoS)-dominated UAV-ground channel---&gt; 较少受到信道损伤的影响，如阴影和衰落</li>
<li>UAV's controllable high mobility in 3D space</li>
</ul>
</li>
<li><strong>UAV communication and trajectory design</strong>中需要考虑的点：
<ul>
<li>throughput</li>
<li>delay</li>
<li>energy</li>
</ul>
</li>
<li>典型应用场景<br>
<img src="https://YI-Pengfei.github.io/post-images/1588846383384.png" alt="" loading="lazy"></li>
</ul>
<ol start="5">
<li><strong>Machine Learning for Wireless Connectivity and Security of Cellular-Connected UAVs</strong></li>
</ol>
<ul>
<li>典型应用场景：<br>
<img src="https://YI-Pengfei.github.io/post-images/1588894998078.png" alt="" loading="lazy">
<ul>
<li>UAV-based delivery system （UAV-DSs)
<ul>
<li>efficient handover and online path planning</li>
</ul>
</li>
<li>UAV-based real-time multimedia streaming (UAV-RMS)</li>
<li>UAV-enabled intelligent transportation systems (UAV-ITS)
<ul>
<li>cooperative multi-UAV data transmission and secured consensus of UAV swarms</li>
</ul>
</li>
</ul>
</li>
<li><img src="https://YI-Pengfei.github.io/post-images/1588900293110.png" alt="" loading="lazy"></li>
</ul>
<ol start="6">
<li><strong>Reinforcement Learning for a Cellular Internet of UAVs: Protocol Design, Trajectory Control, and Resource Management</strong></li>
</ol>
<ul>
<li>无人机收集传感数据发送给基站<br>
<img src="https://YI-Pengfei.github.io/post-images/1589014496803.png" alt="" loading="lazy"></li>
<li>应用：
<ul>
<li>Multi-Armed Bandit Learning for User Association</li>
<li>Q-Learning for Trajectory Control</li>
<li>Actor-Critic Learning for Power Management</li>
<li>Deep Reinforcement Learning for Subchannel Allocation</li>
</ul>
</li>
</ul>
<ol start="7">
<li><strong>UAV Communications Based on Non-Orthogonal Multiple Access</strong></li>
</ol>
<ul>
<li>The key concept of NOMA is to serve multiple users on the same resource block (time/frequency/code/space) but with different power levels. NOMA的关键概念是在相同的资源块(时间/频率/代码/空间)上以不同的功率级别服务多个用户。</li>
<li>使用随机几何进行<strong>网络的性能分析</strong> Using a stocastic-geometry-based model, the ground users are grouped together to share the same resource with NOMA and associated with the most suitable UAV</li>
<li>Joint Power Allocation and Trajectory Design
<ul>
<li>无人机与地面用户之间的通信距离可以根据实时需求进行调整</li>
</ul>
</li>
<li>Dynamic UAV Placement and Movement Design
<ul>
<li>K-means聚类分组 + Q-learning放置无人机+Q-learning实时调整无人机</li>
</ul>
</li>
</ul>
<ol start="9">
<li><strong>Safeguarding Wireless Network with UAVs: A Physical Layer Security Perspective</strong></li>
</ol>
<h4 id="应对地面的干扰窃听者">应对地面的干扰/窃听者</h4>
<ul>
<li>空对地 A2G：
<ul>
<li>3D波束赋形<img src="https://YI-Pengfei.github.io/post-images/1590462402475.png" alt="" loading="lazy"></li>
<li>位置/航迹与通信的协同设计<img src="https://YI-Pengfei.github.io/post-images/1590462416951.png" alt="" loading="lazy"></li>
<li>多无人机协同<img src="https://YI-Pengfei.github.io/post-images/1590462424077.png" alt="" loading="lazy"></li>
</ul>
</li>
<li>地对空G2A
<ul>
<li>同样，无人机端接收的3D波束赋形</li>
<li>调整位置，并且地面可以通过D2D通信将信息转发到其他节点，再由其他节点转发给UAV，以躲避干扰</li>
</ul>
</li>
</ul>
<h4 id="应对空中的干扰窃听者">应对空中的干扰/窃听者</h4>
<ul>
<li>地面通信中应对无人机窃听
<ul>
<li>多跳D2D中继<img src="https://YI-Pengfei.github.io/post-images/1590466434790.png" alt="" loading="lazy"></li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[无人机通信阅读记录-IEEE Communications Magazine]]></title>
        <id>https://YI-Pengfei.github.io/post/wu-ren-ji-tong-xin-yue-du-ji-lu-ieee-communication-magazine/</id>
        <link href="https://YI-Pengfei.github.io/post/wu-ren-ji-tong-xin-yue-du-ji-lu-ieee-communication-magazine/">
        </link>
        <updated>2020-05-03T06:57:47.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li><strong>Aerial Control System for Spectrum Efficiency in UAV-to-Cellular Communications</strong></li>
</ol>
<ul>
<li>利用无人机管理信息降低网络频谱的问题 分离数据平面和控制平面，控制平面由空中的无人机完成</li>
<li>无人机向物联网设备提供5G连接</li>
<li>但是无人机的使用带来了影响频谱效率和网络性能的挑战</li>
<li>自组网self-organized network+ aerial control system (ACS) 空中控制系统</li>
<li>cluster header (CH)负责无人机任务，调整和重新规划</li>
<li>挑战：如何为无人机群分组；如何选首领</li>
</ul>
<ol start="2">
<li><strong>Ultra-Reliable IoT Communications with UAVs: A Swarm Use Case</strong></li>
</ol>
<ul>
<li>超可靠通信 无人机物联网服务</li>
<li>软件层：
<ul>
<li>数据封装：Micro Air Vehicle Communication Protocol (MAVLink)</li>
<li>嵌入式操作系统：OpenWRT 作为托管网络协议的嵌入式操作系统</li>
<li>低延迟通信协议：
<ul>
<li>Mac层对 星形</li>
<li>网络层（也叫路由协议）对 网状</li>
<li>建议将蜂窝网络应用于城市无人机群的广域控制</li>
</ul>
</li>
</ul>
</li>
<li>硬件实现</li>
<li>LoRa</li>
<li>实验对比了WIFI，LoRa，LTE下的可靠性和轮训延迟</li>
</ul>
<ol start="3">
<li><strong>Design of Future UAV-Relay Tactical Data Link for Reliable UAV Control and Situational Awareness</strong></li>
</ol>
<ul>
<li>无人机做中继的战术数据链</li>
<li>基本网络结构：
<ul>
<li>跳频来抗干扰</li>
<li>分布式TDMA 防止单点故障</li>
<li>显式acknowledgment (ACK)，隐式ACK，Mirroring 有效的中继</li>
<li>相对导航和时间同步</li>
</ul>
</li>
<li>频谱分配和管理：</li>
<li>Spectrum Sharing</li>
</ul>
<ol start="4">
<li><strong>ComProSe: Shaping Future Public Safety Communities with ProSe-Based UAVs</strong></li>
</ol>
<ul>
<li>公共安全通信服务 基于ProSe (近距离通信技术 Proximity Services)</li>
<li>主要解决：</li>
<li>不同用户组之间的cooperation</li>
<li>多媒体通信支持</li>
<li>与设备良好的用户交互</li>
<li>解决方案（基于3GPP的近距离通信技术Proximity Services (ProSe) ）由三部分组成：
<ul>
<li>Public safety control center (PS-CC)</li>
</ul>
</li>
<li>Public safety UAV (PS-UAV)</li>
<li>Public safety User (PS-User)</li>
</ul>
<ol start="5">
<li><strong>Aerial Access and Backhaul in mmWave B5G Systems: Performance Dynamics and Optimization</strong></li>
</ol>
<ul>
<li>Integrated access and backhaul (IAB)集成访问和回程 系统设计</li>
<li>需考虑的建模选择：</li>
<li>无人机基站三维布局下的位置</li>
<li>精确地空对地NR(New Radio)传播模型</li>
<li>际的UE（用户设备）部署和运动模型</li>
<li>结合实际的部署考虑</li>
</ul>
<ol start="6">
<li><strong>Power Control in UAV-Supported Ultra Dense Networks: Communications, Caching, and Energy Transfer</strong> <strong>比较有意思，基本的场景和相应的仿真</strong></li>
</ol>
<ul>
<li>超密集网络 Ultra Dense networks (UDNs)  + UAV supported</li>
<li>Power control problem 功率控制问题</li>
<li>需要考虑的点：
<ul>
<li>覆盖率和停机率 Coverage and outage probability   增加发射功率可以提高覆盖率，但是会增加干扰</li>
<li>频谱和能源效率 Spectral/Energy Efficiency</li>
<li>数据率和延迟 network Rate/Delay   高数据率--&gt;高延迟</li>
</ul>
</li>
<li><strong>四种场景下的实验分析</strong>：
<ul>
<li>UAV-supported BS <strong>基站</strong></li>
<li>UAV-supported Relay <strong>中继</strong></li>
<li>UAV-supported Energy Transfer <strong>能量传送</strong></li>
<li>UAV-supported Caching <strong>缓存</strong></li>
</ul>
</li>
</ul>
<ol start="7">
<li><strong>Adaptive Communication Protocols in Flying Ad Hoc Network</strong></li>
</ol>
<ul>
<li>PPMAC Protocol MAC协议:
<ul>
<li>position prediction</li>
<li>communication control</li>
<li>data transission</li>
</ul>
</li>
<li>RLSRP protocol (self-learning routing protocol based on reinforcement learning)</li>
</ul>
<ol start="8">
<li><strong>Spectrum Management for MmWave Enabled UAV Swarm Networks: Challenges and Opportunities</strong></li>
</ol>
<ul>
<li>MmWave+UAV swarm --&gt;Spectrum Management (SM)毫米比+无人机--&gt;频谱管理</li>
</ul>
<ol start="9">
<li><strong>An SDN-MQTT Based Communication System for Battlefield UAV Swarms</strong></li>
</ol>
<ul>
<li>设计了一个战场无人机群通信系统 用软件定义网SDN+MQTT协议  分布式的</li>
</ul>
<ol start="10">
<li><strong>UAV-Aided Cooperation for FSO Communication Systems</strong></li>
</ol>
<ul>
<li>光通信 + 无人机做中继</li>
<li>无人机提供包缓存功能</li>
<li>两个场景：上下悬浮的，  水平远近移动的</li>
</ul>
<ol start="12">
<li><strong>UAVs as Mobile Infrastructure: Addressing Battery Lifetime</strong></li>
</ol>
<ul>
<li>几个UAV轮流提供服务</li>
<li>光换电池</li>
<li>磁场充电、太阳能、激光充电</li>
<li>电池技术改善</li>
</ul>
<ol start="13">
<li><strong>The Sky Is Not the Limit: LTE for Unmanned Aerial Vehicles</strong></li>
</ol>
<ul>
<li>连接需求：
<ul>
<li>命令和控制 (Command and Control)：3GPP requirements on command and control are data rates up to <strong>100 kb/s</strong> and packet error rate lower than <strong>0.1 percent</strong> within <strong>50 ms</strong> latency bound. 命令和控制数据的数据率在100kb/s，包错误率低于0.1%，小于50ms的延迟。</li>
<li>数据通信：比如摄像数据或遥感监视数据要求UAV实时回传图片视频，数据率可能高达50Mb/s。</li>
</ul>
</li>
<li>空中信道特性：
<ul>
<li>视距传输VS非视距传输  视距传输概率与高度、2D距离的关系<br>
<img src="https://YI-Pengfei.github.io/post-images/1589156559852.png" alt="" loading="lazy"></li>
<li>大尺度路径损耗  自由空间、实测、3GPP<br>
<img src="https://YI-Pengfei.github.io/post-images/1589157078858.png" alt="" loading="lazy"></li>
</ul>
</li>
<li>技术可行性和挑战
<ul>
<li>基站天线pattern 水平向、垂向、三维<br>
<img src="https://YI-Pengfei.github.io/post-images/1589157765956.png" alt="" loading="lazy"></li>
</ul>
</li>
<li>潜在增强
<ul>
<li>干扰抑制</li>
<li>机动增强</li>
</ul>
</li>
</ul>
<ol>
<li><strong>UAV-Based IoT Platform+A Crowd Surveillance Use Case</strong></li>
</ol>
<ul>
<li>UAV-Based IoT Plateform<br>
<img src="https://YI-Pengfei.github.io/post-images/1589238302764.png" alt="" loading="lazy"></li>
<li>UAV配备摄像机、4G通信，进行人群监测，<strong>实验</strong>对比onboard计算 和 卸载到MEC(Mobile Edge Computing)的计算效率和能源消耗情况。</li>
</ul>
<ol start="24">
<li><strong>Aerial Access and Backhaul in mmWave B5G Systems: Performance Dynamics and Optimization</strong></li>
</ol>
<ul>
<li>Integrated access and backhaul (IAB)</li>
<li>地面接入点AP，用户UE，无人机基站</li>
<li>建模的考虑上：
<ul>
<li>UAV-BS位置的三维布局</li>
<li>精确的A2G毫米波传输模型</li>
<li>现实的用户部署和移动性模型</li>
<li>结合实际的部署考虑</li>
</ul>
</li>
<li>场景示例：几个AP，几个UAV，用户是分簇的。用户可以直接连AP(UE--&gt;AP)，或者UE--&gt;UAV--&gt;AP。<br>
<img src="https://YI-Pengfei.github.io/post-images/1591667382167.png" alt="" loading="lazy"></li>
<li>方法：
<ul>
<li>Reference Point Group Mobility (RPGM) model描述用户的移动（基本思想是每个簇有个header，header的移动控制着群体的移动）</li>
<li>Particle swarm optimization (PSO)粒子群优化算法做动态优化（基本思想是产生一系列可行解，然后解的迭代受局部最优解和已知全局最优解的综合影响）</li>
<li>Metrics度量：平均用户吞吐量mean UE throughput，公平性fairness (Jain's fairness index)</li>
</ul>
</li>
</ul>
<ol start="25">
<li><strong>Wireless Communications with Unmanned Aerial Vehicles: Opportunities and Challenges 2016年</strong></li>
</ol>
<ul>
<li>基本网络结构：
<ul>
<li>Control and Non-Payload Communications Link 控制链</li>
<li>Data Link 数据链</li>
</ul>
</li>
<li>信道特性
<ul>
<li>空对地：LoS+blocked</li>
<li>空对空：LoS+higher Doppler frequencies</li>
</ul>
</li>
<li>设计考虑：
<ul>
<li>无人机部署和路径规划
<ul>
<li>UAV-aided cellular coverage 可以用多无人机服务多用户，，自旋翼无人机比较好</li>
<li>UAV-aided information dissemination or collection for delay-tolerant data 一架就够了</li>
</ul>
</li>
<li>Energy-Aware deployment and operation
<ul>
<li>energy-aware deployment 比如多架无人机替换着来</li>
<li>energy-efficient operation 减少不必要的能量损耗，比如不上下飞，满足通信需求的同时最小化能量消耗</li>
</ul>
</li>
<li>MIMO for UAV-Aided Communications</li>
</ul>
</li>
<li>两大场景
<ul>
<li>UAV-Enabled Mobile Relaying 往原点飞收数据，往目的地飞发数据，循环往复</li>
<li>D2D-Enhanced UAV Information Dissemination 无人机给地面很多节点发消息，，每个节点可能只能收到一部分，节点之间用D2D通信来交换数据，可以省时省力</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[无人机典型应用场景]]></title>
        <id>https://YI-Pengfei.github.io/post/wu-ren-ji-dian-xing-ying-yong-chang-jing/</id>
        <link href="https://YI-Pengfei.github.io/post/wu-ren-ji-dian-xing-ying-yong-chang-jing/">
        </link>
        <updated>2020-05-03T02:05:59.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>Power Control in UAV-Supported Ultra Dense Networks: Communications, Caching, and Energy Transfer<br>
<img src="https://YI-Pengfei.github.io/post-images/1588471581320.png" alt="" loading="lazy"></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UAV路径规划综述总结]]></title>
        <id>https://YI-Pengfei.github.io/post/uav-lu-jing-gui-hua-zong-shu-zong-jie/</id>
        <link href="https://YI-Pengfei.github.io/post/uav-lu-jing-gui-hua-zong-shu-zong-jie/">
        </link>
        <updated>2020-04-22T02:23:00.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p><a href="https://ieeexplore.ieee.org/document/7053093">A Literature Review of UAV 3D Path Planning</a><br>
<img src="https://YI-Pengfei.github.io/post-images/1587522271745.jpg" alt="" loading="lazy"><br>
<img src="https://YI-Pengfei.github.io/post-images/1587522283490.png" alt="" loading="lazy"></p>
</li>
<li>
<p><a href="https://ieeexplore-ieee-org-443.e2.buaa.edu.cn/document/7953494">Offline and Online Search: UAV Multiobjective<br>
Path Planning Under Dynamic Urban Environment</a><br>
<img src="https://YI-Pengfei.github.io/post-images/1587608593156.png" alt="" loading="lazy"></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[堆优化的A*算法-Python实现]]></title>
        <id>https://YI-Pengfei.github.io/post/dui-you-hua-de-asuan-fa-python-shi-xian/</id>
        <link href="https://YI-Pengfei.github.io/post/dui-you-hua-de-asuan-fa-python-shi-xian/">
        </link>
        <updated>2020-03-27T02:45:13.000Z</updated>
        <content type="html"><![CDATA[<h3 id="堆优化的a算法-python实现">堆优化的A*算法-Python实现</h3>
<ul>
<li><a href="https://blog.csdn.net/FengKuangXiaoZuo/article/details/105135005">笔者CSDN博客地址</a></li>
<li><a href="https://blog.csdn.net/weixin_44489823/article/details/89382502">原理参考博客地址</a></li>
<li><a href="https://blog.csdn.net/gzlaiyonghao/article/details/1329956">代码借鉴地址</a></li>
</ul>
<p>A*算法解决二维网格地图中的寻路问题</p>
<ul>
<li>输入：图片（白色区域代表可行，深色区域代表不行可行）</li>
<li>输出：路径（在图中绘制）</li>
</ul>
<pre><code class="language-python">&quot;&quot;&quot; 方格地图中的A*算法 (openList进行了堆优化)
A* 算法：  F = G+H
F: 总移动代价
G: 起点到当前点的移动代价  直:1, 斜:1.4
H: 当前点到终点的预估代价  曼哈顿距离
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
1.把起点加入 openList中
2.While True:
    a.遍历openList，查找F值最小的节点，作为current
    b.current是终点:
        ========结束========
    c.从openList中弹出，放入closeList中
    d.对八个方位的格点:
        if 越界 or 是障碍物 or 在closeList中:
            continue
        if 不在openList中：
            设置父节点,F,G,H
            加入openList中
        else:
            if 这条路径更好:
                设置父节点,F,G
                更新openList中的对应节点
3.生成路径path
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
堆优化:
    openList：作为最小堆，按F值排序存储坐标 （不更新只增加）
    openDict：坐标:点详细信息 （既更新又增加）
    get_minfNode() 从openList中弹出坐标，去openDict中取点 （但由于不更新只增加，坐标可能冗余）
    in_openList() 判断坐标是否在openDict中即可 

&quot;&quot;&quot;
import math
from PIL import Image,ImageDraw 
import numpy as np
import heapq # 堆

STAT_OBSTACLE='#'
STAT_NORMAL='.'

def manhattan(x1,y1, x2,y2):
    &quot;&quot;&quot;两个Point的曼哈顿距离&quot;&quot;&quot;
    h = abs(x1-x2)+abs(y1-y2)
    return h

class Node():
    &quot;&quot;&quot;
    开放列表和关闭列表的元素类型，parent用来在成功的时候回溯路径
    &quot;&quot;&quot;
    def __init__(self, x, y,parent=None, g=0, h=0):
        self.parent = parent
        self.x = x
        self.y = y
        self.g = g
        self.h = h
        self.update()
    
    def update(self):
        self.f = self.g+self.h


class A_Star:
    &quot;&quot;&quot; x是行索引，y是列索引
    &quot;&quot;&quot;
    def __init__(self, test_map, start=None, end=None):
        &quot;&quot;&quot;地图，起点，终点&quot;&quot;&quot;
        self.map = test_map
        self.cols = len(test_map[0])
        self.rows = len(test_map)
        self.startXY = tuple(start) if start else (0,0)
        self.endXY = tuple(end) if end else (self.rows-1, self.cols-1)
        self.closeList = set()
        self.path = []
        self.openList = []  # 堆，只添加，和弹出最小值点，
        self.openDict = dict() # openList中的 坐标:详细信息 --&gt;不冗余的
        
    
    def find_path(self):
        &quot;&quot;&quot;A*算法寻路主程序&quot;&quot;&quot;
        p = Node(self.startXY[0], self.startXY[1], 
                 h=manhattan(self.startXY[0],self.startXY[1], self.endXY[0],self.endXY[1])) # 构建开始节点
        heapq.heappush(self.openList, (p.f,(p.x,p.y)))
        
        self.openDict[(p.x,p.y)] = p  # 加进dict目录
        while True:
            current = self.get_minfNode()
            if (current.x,current.y)==self.endXY:
                print('found path successfully..')
                self.make_path(current)
                return 
            
            self.closeList.add((current.x,current.y))  ## 加入closeList
            del self.openDict[(current.x,current.y)]
            self.extend_surrounds(current) # 会更新close list

    def make_path(self,p):
        &quot;&quot;&quot;从结束点回溯到开始点，开始点的parent==None&quot;&quot;&quot;
        while p:
            self.path.append((p.x, p.y))
            p = p.parent
    
    def extend_surrounds(self, node):
        &quot;&quot;&quot; 将当前点周围可走的点加到openList中，
            其中 不在openList中的点 设置parent、F,G,H 加进去，
                 在openList中的点  更新parent、F,G,H
        &quot;&quot;&quot;
        motion_direction = [[1, 0], [0,  1], [-1, 0], [0,  -1], 
                            [1, 1], [1, -1], [-1, 1], [-1, -1]]  
        for dx, dy in motion_direction:
            x,y = node.x+dx, node.y+dy
            new_node = Node(x,y)
            # 位置无效，或者是障碍物, 或者已经在closeList中 
            if not self.is_valid_xy(x,y) or not self.not_obstacle(x,y) or self.in_closeList(new_node): 
                continue
            if abs(dx)+abs(dy)==2:  ## 斜向
                h_x,h_y = node.x+dx,node.y # 水平向
                v_x,v_y = node.x,node.y+dy # 垂直向
                if not self.is_valid_xy(h_x,h_y) or not self.not_obstacle(h_x,h_y) or self.in_closeList(Node(h_x,h_y)): 
                    continue
                if not self.is_valid_xy(v_x,v_y) or not self.not_obstacle(v_x,v_y) or self.in_closeList(Node(v_x,v_y)): 
                    continue
            #============ ** 关键 **             ========================
            #============ 不在openList中，加进去； ========================
            #============ 在openList中，更新      ========================
            #============对于openList和openDict来说，操作都一样 ===========
            new_g = node.g + self.cal_deltaG(node.x,node.y, x,y)
            sign=False # 是否执行操作的标志 
            if not self.in_openList(new_node): # 不在openList中
                # 加进来，设置 父节点, F, G, H
                new_node.h = self.cal_H(new_node)
                sign=True
            elif self.openDict[(new_node.x,new_node.y)].g &gt; new_g: # 已在openList中，但现在的路径更好
                sign=True
            if sign:
                new_node.parent = node
                new_node.g = new_g
                new_node.f = self.cal_F(new_node)
                self.openDict[(new_node.x,new_node.y)]=new_node # 更新dict目录
                heapq.heappush(self.openList, (new_node.f,(new_node.x,new_node.y)))
        
    def get_minfNode(self):
        &quot;&quot;&quot;从openList中取F=G+H值最小的 (堆-O(1))&quot;&quot;&quot;
        while True:
            f, best_xy=heapq.heappop(self.openList)
            if best_xy in self.openDict:
                return self.openDict[best_xy]

    def in_closeList(self, node):
        &quot;&quot;&quot;判断是否在closeList中 (集合-O(1)) &quot;&quot;&quot;
        return True if (node.x,node.y) in self.closeList else False
     
    def in_openList(self, node):
        &quot;&quot;&quot;判断是否在openList中 (字典-O(1))&quot;&quot;&quot;
        if not (node.x,node.y) in self.openDict:
            return False
        else:
            return True

    def is_valid_xy(self, x,y):
        if x &lt; 0 or x &gt;= self.rows or y &lt; 0 or y &gt;= self.cols:
            return False
        return True
        
    def not_obstacle(self,x,y):
        return self.map[x][y] != STAT_OBSTACLE
    
    def cal_deltaG(self,x1,y1,x2,y2):
        &quot;&quot;&quot; 计算两点之间行走的代价
            （为简化计算）上下左右直走，代价为1.0，斜走，代价为1.4  G值
        &quot;&quot;&quot;
        if x1 == x2 or y1 == y2:
            return 1.0
        return 1.4
    
    def cal_H(self, node):
        &quot;&quot;&quot; 曼哈顿距离 估计距离目标点的距离&quot;&quot;&quot;
        return abs(node.x-self.endXY[0])+abs(node.y-self.endXY[1]) # 剩余路径的估计长度
    
    def cal_F(self, node):
        &quot;&quot;&quot; 计算F值 F = G+H 
            A*算法的精髓：已经消耗的代价G，和预估将要消耗的代价H
        &quot;&quot;&quot;
        return node.g + node.h

def plot(test_map,path):
    &quot;&quot;&quot;绘制地图和路径
        test_map:二维数组
        path:路径坐标数组
    &quot;&quot;&quot;
    out = []
    for x in range(len(test_map)):
        temp = []
        for y in range(len(test_map[0])):
            if test_map[x][y]==STAT_OBSTACLE:
                temp.append(0)
            elif test_map[x][y]==STAT_NORMAL:
                temp.append(255)
            elif test_map[x][y]=='*':
                temp.append(127)
            else:
                temp.append(255)
        out.append(temp)
    for x,y in path:
        out[x][y] = 127
    out = np.array(out)
    img = Image.fromarray(out)
    img.show()

def path_length(path):
    &quot;&quot;&quot;计算路径长度&quot;&quot;&quot;
    l = 0
    for i in range(len(path)-1):
        x1,y1 = path[i]
        x2,y2 = path[i+1]
        if x1 == x2 or y1 == y2:
            l+=1.0
        else:
            l+=1.4
    return l
    

def img_to_map(img_file):
    &quot;&quot;&quot;地图图片变二维数组&quot;&quot;&quot;
    test_map = []
    img = Image.open(img_file)
    img = img.resize((100,100))  ### resize图片尺寸
    img_gray = img.convert('L')  # 地图灰度化
    img_arr = np.array(img_gray)
    img_binary = np.where(img_arr&lt;127,0,255)
    for x in range(img_binary.shape[0]):
        temp_row = []
        for y in range(img_binary.shape[1]):
            status = STAT_OBSTACLE if img_binary[x,y]==0 else STAT_NORMAL 
            temp_row.append(status)
        test_map.append(temp_row)
    
    return test_map

# ===== test case ===============
test_map=img_to_map('map_1.bmp')
a = A_Star(test_map)
a.find_path()
plot(test_map,a.path)
print('path length:',path_length(a.path))
</code></pre>
<h3 id="测试用例及结果">测试用例及结果</h3>
<p><img src="https://YI-Pengfei.github.io/post-images/1585357842632.png" alt="" loading="lazy"><br>
<img src="https://YI-Pengfei.github.io/post-images/1585357848707.png" alt="" loading="lazy"><br>
<img src="https://YI-Pengfei.github.io/post-images/1585357856210.png" alt="" loading="lazy"></p>
<h3 id="存在的问题">存在的问题</h3>
<p>不确定是否是最优路径<br>
原文描述：<br>
“ If we overestimate this distance, however, it is not guaranteed to give us the shortest path. In such cases, we have what is called an &quot;inadmissible heuristic.&quot;.</p>
<p>Technically, in this example, the Manhattan method is inadmissible because it slightly overestimates the remaining distance.”<br>
即如果我们高估了H，则不能保证最短路径。而曼哈顿距离略微高估了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[智能优化算法]]></title>
        <id>https://YI-Pengfei.github.io/post/zhi-neng-you-hua-suan-fa/</id>
        <link href="https://YI-Pengfei.github.io/post/zhi-neng-you-hua-suan-fa/">
        </link>
        <updated>2020-03-01T01:11:22.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/Frank_LJiang/article/details/90949775">https://blog.csdn.net/Frank_LJiang/article/details/90949775</a><br>
<a href="https://blog.csdn.net/Sinde1992/article/details/50321225">https://blog.csdn.net/Sinde1992/article/details/50321225</a></p>
<h3 id="进化类算法">进化类算法：</h3>
<ul>
<li>遗传算法 起源于20世纪60年代</li>
<li>差分进化算法 1995年</li>
<li>免疫算法 1973年</li>
</ul>
<h3 id="群智能算法">群智能算法</h3>
<ul>
<li>蚁群算法  1992年</li>
<li>粒子群优化算法  1995年</li>
</ul>
<h3 id="模拟退火算法">模拟退火算法</h3>
<h3 id="禁忌搜索算法">禁忌搜索算法</h3>
<h3 id="神经网络算法">神经网络算法</h3>
<p>为了找出地球上最高的山，一群兔子开始想办法</p>
<ol>
<li>兔子朝着比现在高的地方跳去。他们找到了不远处的最高山峰。但是这座山不一定是珠穆朗玛峰。这就是<strong>局部搜索</strong>，它不能保证局部最优值就是全局最优值。</li>
<li>兔子喝醉了。他随机地跳了很长时间。这期间，它可能走向高处，也可能踏入平地。但是，他渐渐清醒了并朝最高方向跳去。这就是<strong>模拟退火</strong>。</li>
<li>兔子们吃了失忆药片，并被发射到太空，然后随机落到了地球上的某些地方。他们不知道自己的使命是什么。但是，如果你过几年就杀死一部分海拔低的兔子，多产的兔子们自己就会找到珠穆朗玛峰。这就是<strong>遗传算法</strong>。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python画图 三维]]></title>
        <id>https://YI-Pengfei.github.io/post/python-hua-tu-san-wei/</id>
        <link href="https://YI-Pengfei.github.io/post/python-hua-tu-san-wei/">
        </link>
        <updated>2020-02-27T23:16:14.000Z</updated>
        <content type="html"><![CDATA[<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo><mo>=</mo><mn>5</mn><mi>s</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>x</mi><mi>y</mi><mo>)</mo><mo>+</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">f(x,y)=5sin(xy)+x^2+y^2
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">5</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9474379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0585479999999998em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p>
<pre><code class="language-python">from mpl_toolkits.mplot3d import Axes3D
from matplotlib import cm
import matplotlib.pyplot as plt
import numpy as np
import mpl_toolkits.mplot3d
import math

def func(X):
    x,y=X[0],X[1]
    &quot;&quot;&quot;x,y为两个数值变量&quot;&quot;&quot;
    z = 5*np.sin(x*y)+x**2+y**2
    return z

def plot():
    figure=plt.figure()
    #ax = Axes3D(figure)
    ax=figure.gca(projection=&quot;3d&quot;)
    x1=np.arange(-4,4,0.02)
    y1=np.arange(-4,4,0.02)
    x,y =np.meshgrid(x1,y1)
    z=func([x,y])
    #ax.plot_surface(x,y,z,rstride=10,cstride=4,cmap=cm.YlGnBu_r)
    ax.plot_surface(x,y,z,cmap=&quot;rainbow&quot;)
    plt.show()

plot()
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://YI-Pengfei.github.io/post-images/1582852756703.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[应用tflearn实现神经网络-一个简单的例子]]></title>
        <id>https://YI-Pengfei.github.io/post/ying-yong-tflearn-shi-xian-shen-jing-wang-luo-yi-ge-jian-dan-de-li-zi/</id>
        <link href="https://YI-Pengfei.github.io/post/ying-yong-tflearn-shi-xian-shen-jing-wang-luo-yi-ge-jian-dan-de-li-zi/">
        </link>
        <updated>2020-02-21T03:16:47.000Z</updated>
        <content type="html"><![CDATA[<p>tflearn官方文档 <a href="http://tflearn.org/">http://tflearn.org/</a><br>
&quot;&quot;&quot;<br>
练习tensorflow和tflearn<br>
&quot;&quot;&quot;</p>
<pre><code class="language-python">import tensorflow as tf
import tflearn
import numpy as np
import random
from matplotlib import pyplot as plt

tf.reset_default_graph()

def generate_data(n=5, num=1000):
    &quot;&quot;&quot;产生测试用的数据&quot;&quot;&quot;
    d = [0,1]

    allX = []
    allY = []
    for count in range(num):
        lst = []
        label = [0,1]
        for i in range(n):
            rnd = random.choice(d)
            if len(lst)&gt;=1 and rnd==1 and rnd==lst[-1]:
                label = [1,0]   ## 有连续两个1
            lst.append(rnd)
        allX.append(lst)
        allY.append(label)
    ## 随机将数据分为两组，训练组 和 测试组
    allX = np.array(allX)
    allY = np.array(allY)
    trainIndex = sorted(random.sample(list(range(num)), int(num/5)))
    testIndex = sorted(list(set(range(num))- set(trainIndex)))
    trainX, trainY = allX[trainIndex,:], allY[trainIndex ,:]
    testX, testY = allX[testIndex,:], allY[testIndex ,:]

    return trainX, trainY, testX, testY


def train_model(trainX, trainY, acti):
    &quot;&quot;&quot;构建神经网络，训练神经网络&quot;&quot;&quot;
    n_in, n_out = len(trainX[0]), len(trainY[0])
    net = tflearn.input_data(shape=[None, n_in])
    net = tflearn.fully_connected(net, 8, activation=acti)
    net = tflearn.fully_connected(net, 8, activation=acti)
    net = tflearn.fully_connected(net, n_out, activation=acti)
    net = tflearn.regression(net, optimizer='adam', 
                             loss='categorical_crossentropy',
                             learning_rate=0.01)
    
    model = tflearn.DNN(net, tensorboard_verbose=3)
    model.fit(trainX, trainY, n_epoch=100, show_metric=True, batch_size=50)
    return model


def test_model(model, testX, testY):
    &quot;&quot;&quot;测试神经网络&quot;&quot;&quot;
    pred = model.predict(testX)
    n_right=0
    for i,lst in enumerate(pred):
        if lst[0]&gt;lst[1]:
            res = [1,0]
        else:
            res = [0,1]
        if res==testY[i].tolist():
            n_right+=1
        
    accuracy = n_right/len(pred)
    return accuracy


trainX, trainY, testX, testY = generate_data(n=5, num=1000)
model = train_model(trainX, trainY, acti='softmax') # 训练模型
accuracy = test_model(model, testX, testY)
print('Predict accuracy is:%f'%accuracy)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关联规则学习 Association rule learning]]></title>
        <id>https://YI-Pengfei.github.io/post/guan-lian-gui-ze-xue-xi-association-rule-learning/</id>
        <link href="https://YI-Pengfei.github.io/post/guan-lian-gui-ze-xue-xi-association-rule-learning/">
        </link>
        <updated>2020-02-21T03:06:05.000Z</updated>
        <content type="html"><![CDATA[<p><a href="http://rasbt.github.io/mlxtend/api_subpackages/mlxtend.frequent_patterns/">http://rasbt.github.io/mlxtend/api_subpackages/mlxtend.frequent_patterns/</a><br>
&quot;&quot;&quot;<br>
关联规则学习 Association rule learning 的目的是从大数据中发现变量之间的相关性<br>
如&quot;啤酒和尿布&quot;的故事<br>
Apriori alogrithm<br>
实现Apriori alogrithm 用 mlxtend.frequent_patterns<br>
&quot;&quot;&quot;</p>
<pre><code class="language-python">import pandas as pd
from mlxtend.frequent_patterns import apriori
from mlxtend.frequent_patterns import association_rules
## 创建数据
columns = ['Milk', 'Bread', 'Butter', 'Beer', 'Diaper']
L_transactions=[[1,1,0,0,0],
                [0,0,1,0,0],
                [0,0,0,1,1],
                [1,1,1,0,0],
                [0,1,0,0,0]]
df = pd.DataFrame(L_transactions, columns=columns)

frequent_itemsets=apriori(df,min_support=0.4)  ## 计算频繁项集 p&gt;0.4
print(frequent_itemsets)

rules = association_rules(frequent_itemsets, metric='confidence', min_threshold=0.5)  ## 求关联规则
print(rules)
</code></pre>
<p>输出：</p>
<pre><code class="language-python">   support itemsets
0      0.4      (0)
1      0.6      (1)
2      0.4      (2)
3      0.4   (0, 1)
  antecedents consequents     ...      leverage  conviction
0         (0)         (1)     ...          0.16         inf
1         (1)         (0)     ...          0.16    1.800000

[2 rows x 9 columns]
</code></pre>
]]></content>
    </entry>
</feed>